#### 快速排序也许是最常用的排序算法了。它的复杂度为O(nlog n ),且它的性能通常比其他的复
杂度为O(nlog n )的排序算法要好。和归并排序一样,快速排序也使用分治的方法,将原始数组分
#### 为较小的数组(但它没有像归并排序那样将它们分割开)。
#### 快速排序比到目前为止你学过的其他排序算法要复杂一些。
#### 让我们一步步地来学习。
#### (1) 
  首先,从数组中选择中间一项作为主元。
#### (2) 
  创建两个指针,左边一个指向数组第一个项,右边一个指向数组最后一个项。移动左指针直到我们找到一个比主元大的元素,接着,移动右指针直到找到一个比主元小的元素,然后交换它们,重复这个过程,直到左指针超过了右指针。这个过程将使得比主元小的值都排在主元之前,而比主元大的值都排在主元之后。这一步叫作划分操作。
#### (3)
  接着,算法对划分后的小数组(较主元小的值组成的子数组,以及较主元大的值组成的子数组)重复之前的两个步骤,直至数组已完全排序。
  
  
#### 
```javascript
/*
第一次划分操作： 
  left = 0
  right = 6
  pivot = 3
    在发生首次元素事件之后：[3, 5, 1, 2, 4, 7, 6]
      i++ 跟 j++ 是为了跳过已经做了位置交换元素
    这时候，第一次划分操作还没有结束。
    第二次比较开始
      i = 4
      j = 5
      pivot = 6
      array[4] < 6   4 < 6
      i++;//i=5
      array[5] > 6    7 > 6
      j--; // j = 4
    到了这里， i<=j 的条件不成立了，while语句停止执行 
      return 5
第二次划分操作：
  left = 0
  right = 4
  pivot = 2
    在发生首次元素事件之后：[1, 5, 3, 2, 4]
      i++ 跟 j++ 是为了跳过已经做了位置交换元素
    第二次比较开始
      i = 0
      j = 1
      pivot = 1
      array[0] < 1    5 < 1 false
      i++;//i=2
      array[1] > 1    5 > 1 true
      j--; // j = 0
    到了这里， i<=j 的条件不成立了，while语句停止执行 
      return 1
第三次划分操作：
  left = 1
  right = 2
  pivot = 3
    在发生首次元素事件之后：[3, 2]
      i++ 跟 j++ 是为了跳过已经做了位置交换元素
    第二次比较开始
      i = 1
      j = 1
      pivot = 3
      array[1] < 3    3 < 3 false
      i++;//i=2
      array[1] > 3    3 > 3 false
      j--; // j = 0
    到了这里， i<=j 的条件不成立了，while语句停止执行 
      return 2
           
1: 
  left 0 < index 6 - 1: true
    [ 3, 5, 1, 6, 4, 7, 2 ]
    return 5
2: 
  left 0 < index 5 - 1: true
    [ 3, 5, 1, 2, 4, 7, 6 ]
    return 1 
3: 
  index 1 < right 4: true
    [ 1, 5, 3, 2, 4, 7, 6 ]
    return 3
4: 
  left 1 < index 3 - 1: true
    [ 1, 2, 3, 5, 4, 7, 6 ]
    return 2
5: 
  index 3 < right 4: true
    [ 1, 2, 3, 5, 4, 7, 6 ]
    return 4
6： 
  index 5 < right 6: true
    [ 1, 2, 3, 4, 5, 7, 6 ]
    return 6
    
思路：
  第一步找到主元，将其分大小
*/
```


### [wiki](// https://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F#PHP)